# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: ignore
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/vcr/all/vcr.rbi
#
# vcr-6.2.0

module VCR
  def cassette_persisters; end
  def cassette_serializers; end
  def cassettes(context = nil); end
  def config; end
  def configuration; end
  def configure; end
  def context_cassettes; end
  def context_value(name); end
  def cucumber_tags(&block); end
  def current_cassette; end
  def current_context; end
  def dup_context(context); end
  def eject_cassette(options = nil); end
  def fibers_available?; end
  def get_context(thread_key, fiber_key = nil); end
  def http_interactions; end
  def ignore_cassettes?; end
  def initialize_fibers; end
  def initialize_ivars; end
  def insert_cassette(name, options = nil); end
  def library_hooks; end
  def link_context(from_thread, to_key); end
  def real_http_connections_allowed?; end
  def record_http_interaction(interaction); end
  def request_ignorer; end
  def request_matchers; end
  def self.const_missing(const); end
  def set_context_value(name, value); end
  def turn_off!(options = nil); end
  def turn_on!; end
  def turned_off(options = nil); end
  def turned_on(options = nil); end
  def turned_on?; end
  def unlink_context(key); end
  def use_cassette(name, options = nil, &block); end
  def use_cassettes(cassettes, &block); end
  def version; end
  extend VCR
  extend VCR
  include VCR::Errors
  include VCR::VariableArgsBlockCaller
end
class VCR::Logger
  def initialize(stream); end
  def log(message, log_prefix, indentation_level = nil); end
  def request_summary(request, request_matchers); end
  def response_summary(response); end
end
module VCR::Logger::Null
  def log(*arg0); end
  def request_summary(*arg0); end
  def response_summary(*arg0); end
  def self.log(*arg0); end
  def self.request_summary(*arg0); end
  def self.response_summary(*arg0); end
end
module VCR::Logger::Mixin
  def log(message, indentation_level = nil); end
  def request_summary(*args); end
  def response_summary(*args); end
end
module VCR::VariableArgsBlockCaller
  def call_block(block, *args); end
end
class VCR::Cassette
  def assert_valid_options!; end
  def assign_tags; end
  def clean_outdated_http_interactions; end
  def deserialized_hash; end
  def drop_unused_requests; end
  def eject(options = nil); end
  def erb; end
  def extract_options; end
  def file; end
  def http_interactions; end
  def initialize(name, options = nil); end
  def interactions_to_record; end
  def invoke_hook(type, interactions); end
  def linked?; end
  def log_prefix; end
  def match_requests_on; end
  def merged_interactions; end
  def name; end
  def new_recorded_interactions; end
  def originally_recorded_at; end
  def previously_recorded_interactions; end
  def raise_error_unless_valid_record_mode; end
  def raw_cassette_bytes; end
  def re_record_interval; end
  def record_http_interaction(interaction); end
  def record_mode; end
  def record_on_error; end
  def recording?; end
  def request_summary(request); end
  def run_failed!; end
  def run_failed?; end
  def self.const_missing(const); end
  def serializable_hash; end
  def should_assert_no_unused_interactions?; end
  def should_re_record?(record_mode); end
  def should_remove_matching_existing_interactions?; end
  def should_remove_unused_interactions?; end
  def should_stub_requests?; end
  def should_write_recorded_interactions_to_disk?; end
  def storage_key; end
  def tags; end
  def up_to_date_interactions(interactions); end
  def write_recorded_interactions_to_disk; end
  include VCR::Logger::Mixin
end
class VCR::Cassette::HTTPInteractionList
  def allow_playback_repeats; end
  def assert_no_unused_interactions!; end
  def has_interaction_matching?(request); end
  def has_unused_interactions?; end
  def has_used_interaction_matching?(request); end
  def initialize(interactions, request_matchers, allow_playback_repeats = nil, parent_list = nil, log_prefix = nil); end
  def interaction_matches_request?(request, interaction); end
  def interactions; end
  def log_prefix; end
  def matching_interaction_index_for(request); end
  def matching_used_interaction_for(request); end
  def parent_list; end
  def remaining_unused_interaction_count; end
  def request_matchers; end
  def request_summary(request); end
  def response_for(request); end
  include VCR::Logger::Mixin
end
module VCR::Cassette::HTTPInteractionList::NullList
  def has_interaction_matching?(*a); end
  def has_used_interaction_matching?(*a); end
  def remaining_unused_interaction_count(*a); end
  def response_for(*a); end
  extend VCR::Cassette::HTTPInteractionList::NullList
end
class VCR::Cassette::ERBRenderer
  def binding_for_variables; end
  def erb_variables; end
  def handle_name_error(e); end
  def initialize(raw_template, erb, cassette_name = nil); end
  def render; end
  def template; end
  def use_erb?; end
  def variables_object; end
end
class VCR::Cassette::Serializers
  def [](name); end
  def []=(name, value); end
  def initialize; end
end
module VCR::Cassette::EncodingErrorHandling
  def handle_encoding_errors; end
end
module VCR::Cassette::SyntaxErrorHandling
  def handle_syntax_errors; end
end
class VCR::Cassette::Persisters
  def [](name); end
  def []=(name, value); end
  def initialize; end
end
module VCR::Errors
end
class VCR::Errors::Error < StandardError
end
class VCR::Errors::CassetteInUseError < VCR::Errors::Error
end
class VCR::Errors::TurnedOffError < VCR::Errors::Error
end
class VCR::Errors::MissingERBVariableError < VCR::Errors::Error
end
class VCR::Errors::LibraryVersionTooLowError < VCR::Errors::Error
end
class VCR::Errors::UnregisteredMatcherError < VCR::Errors::Error
end
class VCR::Errors::InvalidCassetteFormatError < VCR::Errors::Error
end
class VCR::Errors::AroundHTTPRequestHookError < VCR::Errors::Error
end
class VCR::Errors::NotSupportedError < VCR::Errors::Error
end
class VCR::Errors::UnknownContentEncodingError < VCR::Errors::Error
end
class VCR::Errors::UnusedHTTPInteractionError < VCR::Errors::Error
end
class VCR::Errors::EjectLinkedCassetteError < VCR::Errors::Error
end
class VCR::Errors::UnhandledHTTPRequestError < VCR::Errors::Error
  def cassettes_description; end
  def cassettes_list; end
  def construct_message; end
  def current_cassettes; end
  def current_matchers; end
  def format_bullet_point(lines, index); end
  def format_foot_note(url, index); end
  def formatted_headers; end
  def formatted_suggestions; end
  def has_used_interaction_matching?; end
  def initialize(request); end
  def match_request_on_body?; end
  def match_request_on_headers?; end
  def match_requests_on_suggestion; end
  def no_cassette_suggestions; end
  def record_mode_suggestion; end
  def relish_version_slug; end
  def request; end
  def request_description; end
  def suggestion_for(key); end
  def suggestions; end
end
class VCR::LinkedCassette < SimpleDelegator
  def eject(*args); end
  def linked?; end
  def self.list(cassettes, linked_cassettes); end
end
class VCR::LinkedCassette::CassetteList
  def each; end
  def initialize(cassettes, linked_cassettes); end
  def last; end
  def size; end
  def wrap(cassette); end
  include Enumerable
end
module VCR::Hooks
  def clear_hooks; end
  def has_hooks_for?(hook_type); end
  def hooks; end
  def invoke_hook(hook_type, *args); end
  def self.included(klass); end
  include VCR::VariableArgsBlockCaller
end
class VCR::Hooks::FilteredHook < Struct
  def conditionally_invoke(*args); end
  def filters; end
  def filters=(_); end
  def hook; end
  def hook=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  include VCR::VariableArgsBlockCaller
end
module VCR::Hooks::ClassMethods
  def define_hook(hook_type, prepend = nil); end
end
class VCR::Configuration
  def after_http_request(*filters); end
  def allow_http_connections_when_no_cassette=(arg0); end
  def allow_http_connections_when_no_cassette?; end
  def around_http_request(*filters, &block); end
  def before_playback(tag = nil, &block); end
  def before_record(tag = nil, &block); end
  def cassette_library_dir; end
  def cassette_library_dir=(dir); end
  def cassette_persisters; end
  def cassette_serializers; end
  def configure_rspec_metadata!; end
  def create_fiber_for(fiber_errors, hook_declaration, proc); end
  def debug_logger; end
  def debug_logger=(value); end
  def default_cassette_options; end
  def default_cassette_options=(overrides); end
  def define_cassette_placeholder(placeholder, tag = nil, &block); end
  def filter_sensitive_data(placeholder, tag = nil, &block); end
  def hook_into(*hooks); end
  def ignore_host(*hosts); end
  def ignore_hosts(*hosts); end
  def ignore_localhost=(value); end
  def ignore_request(&block); end
  def initialize; end
  def load_library_hook(hook); end
  def log_prefix; end
  def logger; end
  def preserve_exact_body_bytes_for?(http_message); end
  def query_parser; end
  def query_parser=(arg0); end
  def register_built_in_hooks; end
  def register_request_matcher(name, &block); end
  def request_filter_from(object); end
  def resume_fiber(fiber, fiber_errors, response, hook_declaration); end
  def start_new_fiber_for(request, fibers, fiber_errors, hook_declaration, proc); end
  def stub_with(*adapters); end
  def tag_filter_from(tag); end
  def unignore_host(*hosts); end
  def unignore_hosts(*hosts); end
  def uri_parser; end
  def uri_parser=(arg0); end
  extend VCR::Hooks::ClassMethods
  include VCR::Configuration::DefinedHooks
  include VCR::Hooks
  include VCR::Logger::Mixin
  include VCR::VariableArgsBlockCaller
end
module VCR::Configuration::DefinedHooks
  def after_http_request(*filters, &hook); end
  def after_library_hooks_loaded(*filters, &hook); end
  def before_http_request(*filters, &hook); end
  def before_playback(*filters, &hook); end
  def before_record(*filters, &hook); end
  def preserve_exact_body_bytes(*filters, &hook); end
end
module VCR::Deprecations
end
module VCR::Deprecations::Middleware
end
module VCR::Deprecations::Middleware::Faraday
  def initialize(*args); end
end
class VCR::LibraryHooks
  def disabled?(hook); end
  def exclusive_hook; end
  def exclusive_hook=(arg0); end
  def exclusively_enabled(hook); end
end
class VCR::RequestIgnorer
  def ignore?(request); end
  def ignore_hosts(*hosts); end
  def ignore_localhost=(value); end
  def ignored_hosts; end
  def initialize; end
  def localhost_ignored?; end
  def unignore_hosts(*hosts); end
  extend VCR::Hooks::ClassMethods
  include VCR::Hooks
  include VCR::RequestIgnorer::DefinedHooks
end
module VCR::RequestIgnorer::DefinedHooks
  def ignore_request(*filters, &hook); end
end
class VCR::RequestMatcherRegistry
  def [](matcher); end
  def initialize; end
  def raise_unregistered_matcher_error(name); end
  def register(name, &block); end
  def register_built_ins; end
  def try_to_register_body_as_json; end
  def uri_without_param(*ignores); end
  def uri_without_param_matchers; end
  def uri_without_params(*ignores); end
end
class Anonymous_Struct_221 < Struct
  def callable; end
  def callable=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::RequestMatcherRegistry::Matcher < Anonymous_Struct_221
  def matches?(request_1, request_2); end
end
class Anonymous_Struct_222 < Struct
  def params_to_ignore; end
  def params_to_ignore=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::RequestMatcherRegistry::URIWithoutParamsMatcher < Anonymous_Struct_222
  def call(request_1, request_2); end
  def partial_uri_from(request); end
  def to_proc; end
end
module VCR::Normalizers
end
module VCR::Normalizers::Body
  def base_body_hash(body); end
  def initialize(*args); end
  def self.included(klass); end
  def serializable_body; end
end
module VCR::Normalizers::Body::ClassMethods
  def body_from(hash_or_string); end
  def force_encode_string(string, encoding); end
  def try_encode_string(string, encoding); end
end
module VCR::Normalizers::Header
  def convert_to_raw_strings(array); end
  def delete_header(key); end
  def edit_header(key, value = nil); end
  def get_header(key); end
  def header_key(key); end
  def initialize(*args); end
  def normalize_headers; end
end
class Anonymous_Struct_223 < Struct
  def body; end
  def body=(_); end
  def headers; end
  def headers=(_); end
  def method; end
  def method=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def uri; end
  def uri=(_); end
end
class VCR::Request < Anonymous_Struct_223
  def initialize(*args); end
  def method(*args); end
  def parsed_uri; end
  def self.from_hash(hash); end
  def to_hash; end
  def without_standard_port(uri); end
  extend VCR::Normalizers::Body::ClassMethods
  include VCR::Normalizers::Body
  include VCR::Normalizers::Header
end
class VCR::Request::Typed < Anonymous_Delegator_224
  def externally_stubbed?; end
  def ignored?; end
  def initialize(request, type); end
  def real?; end
  def recordable?; end
  def stubbed?; end
  def stubbed_by_vcr?; end
  def type; end
  def unhandled?; end
end
class VCR::Request::FiberAware < Anonymous_Delegator_225
  def proceed; end
  def to_proc; end
end
class Anonymous_Struct_226 < Struct
  def adapter_metadata; end
  def adapter_metadata=(_); end
  def body; end
  def body=(_); end
  def headers; end
  def headers=(_); end
  def http_version; end
  def http_version=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def status; end
  def status=(_); end
end
class VCR::Response < Anonymous_Struct_226
  def compressed?; end
  def content_encoding; end
  def decompress; end
  def initialize(*args); end
  def recompress; end
  def self.decompress(body, type); end
  def self.from_hash(hash); end
  def to_hash; end
  def update_content_length_header; end
  def vcr_decompressed?; end
  extend VCR::Normalizers::Body::ClassMethods
  include VCR::Normalizers::Body
  include VCR::Normalizers::Header
end
class Anonymous_Struct_227 < Struct
  def code; end
  def code=(_); end
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::ResponseStatus < Anonymous_Struct_227
  def self.from_hash(hash); end
  def to_hash; end
end
class Anonymous_Struct_228 < Struct
  def recorded_at; end
  def recorded_at=(_); end
  def request; end
  def request=(_); end
  def response; end
  def response=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class VCR::HTTPInteraction < Anonymous_Struct_228
  def hook_aware; end
  def initialize(*args); end
  def self.from_hash(hash); end
  def to_hash; end
end
class VCR::HTTPInteraction::HookAware < Anonymous_Delegator_229
  def filter!(text, replacement_text); end
  def filter_hash!(hash, text, replacement_text); end
  def filter_object!(object, text, replacement_text); end
  def ignore!; end
  def ignored?; end
  def initialize(http_interaction); end
end
module VCR::RSpec
end
module VCR::Middleware
end
