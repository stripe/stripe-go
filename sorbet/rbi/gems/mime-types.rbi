# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/mime-types/all/mime-types.rbi
#
# mime-types-3.3.1

module MIME
end
class MIME::Type
  def <=>(other); end
  def add_extensions(*extensions); end
  def ascii?; end
  def binary?; end
  def complete?; end
  def content_type; end
  def content_type=(type_string); end
  def default_encoding; end
  def docs; end
  def docs=(arg0); end
  def encode_with(coder); end
  def encoding; end
  def encoding=(enc); end
  def eql?(other); end
  def extensions; end
  def extensions=(value); end
  def friendly(lang = nil); end
  def i18n_key; end
  def init_with(coder); end
  def initialize(content_type); end
  def inspect; end
  def intern_string(string); end
  def like?(other); end
  def media_type; end
  def obsolete; end
  def obsolete=(arg0); end
  def obsolete?; end
  def preferred_extension; end
  def preferred_extension=(value); end
  def priority_compare(other); end
  def raw_media_type; end
  def raw_sub_type; end
  def registered; end
  def registered=(arg0); end
  def registered?; end
  def self.i18n_key(content_type); end
  def self.match(content_type); end
  def self.simplified(content_type, remove_x_prefix: nil); end
  def self.simplify_matchdata(matchdata, remove_x = nil, joiner: nil); end
  def signature; end
  def signature=(arg0); end
  def signature?; end
  def simplified; end
  def sub_type; end
  def to_h; end
  def to_json(*args); end
  def to_s; end
  def to_str; end
  def use_instead; end
  def use_instead=(arg0); end
  def xref_map(values, helper); end
  def xref_url_for_draft(value); end
  def xref_url_for_person(value); end
  def xref_url_for_rfc(value); end
  def xref_url_for_rfc_errata(value); end
  def xref_url_for_template(value); end
  def xref_urls; end
  def xrefs; end
  def xrefs=(xrefs); end
  include Comparable
end
class MIME::Type::InvalidContentType < ArgumentError
  def initialize(type_string); end
  def to_s; end
end
class MIME::Type::InvalidEncoding < ArgumentError
  def initialize(encoding); end
  def to_s; end
end
class MIME::Types::Cache < Struct
  def data; end
  def data=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.load(cache_file = nil); end
  def self.members; end
  def self.new(*arg0); end
  def self.save(types = nil, cache_file = nil); end
  def version; end
  def version=(_); end
end
class MIME::Types::Container
  def ==(*args, &block); end
  def [](key); end
  def []=(key, value); end
  def add(key, value); end
  def container; end
  def container=(arg0); end
  def count(*args, &block); end
  def each(*args, &block); end
  def each_value(*args, &block); end
  def empty?(*args, &block); end
  def encode_with(coder); end
  def flat_map(*args, &block); end
  def init_with(coder); end
  def initialize(hash = nil); end
  def keys(*args, &block); end
  def marshal_dump; end
  def marshal_load(hash); end
  def merge!(other); end
  def merge(other); end
  def normalize; end
  def select(*args, &block); end
  def to_hash; end
  def values(*args, &block); end
  extend Forwardable
end
class MIME::Types
  def [](type_id, complete: nil, registered: nil); end
  def add(*types); end
  def add_type(type, quiet = nil); end
  def add_type_variant!(mime_type); end
  def count; end
  def each; end
  def index_extensions!(mime_type); end
  def initialize; end
  def inspect; end
  def match(pattern); end
  def of(filename); end
  def prune_matches(matches, complete, registered); end
  def reindex_extensions!(mime_type); end
  def self.[](type_id, complete: nil, registered: nil); end
  def self.__instances__; end
  def self.__types__; end
  def self.add(*types); end
  def self.count; end
  def self.each; end
  def self.lazy_load?; end
  def self.load_default_mime_types(mode = nil); end
  def self.load_mode; end
  def self.logger; end
  def self.logger=(arg0); end
  def self.new(*arg0); end
  def self.of(filename); end
  def self.reindex_extensions(type); end
  def self.type_for(filename); end
  def type_for(filename); end
  include Enumerable
end
class MIME::Types::Loader
  def columnar_path; end
  def container; end
  def initialize(path = nil, container = nil); end
  def json_path; end
  def load(options = nil); end
  def load_columnar; end
  def load_json; end
  def load_yaml; end
  def path; end
  def self.load(options = nil); end
  def self.load_from_json(filename); end
  def self.load_from_yaml(filename); end
  def self.read_file(filename); end
  def yaml_path; end
end
class MIME::Types::WarnLogger < Logger
  def initialize(_one, _two = nil, _three = nil); end
end
class MIME::Types::WarnLogger::WarnLogDevice < Logger::LogDevice
  def close; end
  def initialize(*arg0); end
  def write(m); end
end
class MIME::Type::Columnar < MIME::Type
  def docs(*args); end
  def docs=(*args); end
  def encode_with(coder); end
  def encoding(*args); end
  def encoding=(*args); end
  def friendly(*args); end
  def initialize(container, content_type, extensions); end
  def obsolete(*args); end
  def obsolete=(*args); end
  def obsolete?(*args); end
  def preferred_extension(*args); end
  def preferred_extension=(*args); end
  def registered(*args); end
  def registered=(*args); end
  def registered?(*args); end
  def signature(*args); end
  def signature=(*args); end
  def signature?(*args); end
  def use_instead(*args); end
  def use_instead=(*args); end
  def xref_urls(*args); end
  def xrefs(*args); end
  def xrefs=(*args); end
end
module MIME::Types::Columnar
  def arr(line); end
  def dict(line, array: nil); end
  def each_file_line(name, lookup = nil); end
  def flag(line); end
  def load_base_data(path); end
  def load_docs; end
  def load_encoding; end
  def load_flags; end
  def load_friendly; end
  def load_preferred_extension; end
  def load_use_instead; end
  def load_xrefs; end
  def opt(line); end
  def self.extended(obj); end
end
