version: 2.1

# if `workflows` is not specified only the `build` job is run
# prevent more than a single build from running at one time
# https://jira.corp.stripe.com/browse/REPROD-1231
orbs:
  ruby: circleci/ruby@1.8.0
  browser-tools: circleci/browser-tools@1.4.0
  # https://circleci.com/developer/orbs/orb/circleci/salesforce-apex#commands-test
  sfdx: circleci/salesforce-sfdx@2.2.0
  jq: circleci/jq@2.2.0
workflows:
  version: 2
  build_typecheck_rubocop:
    jobs: &build_typecheck_rubocop_jobs
      - block_workflow:
          # builds can take ~2hrs when NetSuite is slow and
          # a build could be pending on multiple builds
          # 6hrs is an insane value, but it's better than waking up to a bunch of
          # broken builds that you need to re-run
          time: "1440"
      - clean_salesforce:
          matrix: &ruby_test_accounts
            parameters:
              # # https://docs.google.com/spreadsheets/d/136PUl_U7bMW7uMSwcqujisasAJNQJIOPQimGGG7iG00/edit#gid=0
              account:
                - mbianco+standardcpq@stripe.com
                - mbianco+cpqpackage@stripe.com

          requires:
            # We will wait for the block and typecheck tasks to complete
            # We intentionally do not wait for the results of rubocop as it's not necessary
            - block_workflow
            - typecheck
            - salesforce
      - build:
          matrix: *ruby_test_accounts

          requires:
            - clean_salesforce
      - typecheck
      - rubocop
      - salesforce:
          name: salesforce-<< matrix.account >>
          requires: ["block_workflow"]
          matrix:
            parameters:
              # https://docs.google.com/spreadsheets/d/136PUl_U7bMW7uMSwcqujisasAJNQJIOPQimGGG7iG00/edit#gid=0
              account:
                - mbianco+standardcpq@stripe.com
                - mbianco+cpqmulticurrency@stripe.com
                - mbianco+cpqplus@stripe.com
                - mbianco+noncpq@stripe.com
                - mbianco+cpqubp@stripe.com

  nightly:
    jobs: *build_typecheck_rubocop_jobs

    triggers:
      - schedule:
          cron: "0 4 * * *"
          filters:
            branches:
              only:
                - main

jobs:
  typecheck:
    docker:
      - image: cimg/ruby:2.7.6
    steps:
      - checkout
      - ruby/install-deps
      - run: bundle exec srb tc

  rubocop:
    docker:
      - image: cimg/ruby:2.7.6
    steps:
      - checkout
      - ruby/install-deps
      - run: bundle exec rubocop

  salesforce:
    parameters:
      account:
        type: string
    executor: sfdx/default
    environment:
      # TODO can we share this across jobs?
      SF_JWT_PRIVATE_KEY_PATH: /home/circleci/project/private.key
    docker:
      # use the same version as exists locally
      - image: cimg/node:16.14.2
    steps:
      - checkout
      - sfdx/install: &sfdx_version
          version: '7.161.0'
      - run: sfdx/bin/run-tests <<parameters.account>>
      - store_test_results:
          path: sfdx/test-results
      - store_artifacts:
          destination: apex-test-results
          path: sfdx/test-results

  clean_salesforce:
    parameters:
      account:
        type: string
    executor: sfdx/default
    environment:
      # TODO can we share this across jobs?
      SF_JWT_PRIVATE_KEY_PATH: /home/circleci/project/private.key
    steps:
      - checkout
      - sfdx/install: *sfdx_version
      - run:
          name: Delete Salesforce Test Data
          command: |
            ./sfdx/bin/extract-private-key

            source ./sfdx/bin/run-tests-helpers

            cd sfdx

            authorizeSalesforceAccount <<parameters.account>>

            # this only needs to be done once for all parallel builds, which is why we have a separate job we are using here
            deleteTestData <<parameters.account>>

  build:
    parallelism: 10
    parameters:
      account:
        type: string
    environment:
      CIRCLE_ARTIFACTS: /tmp/artifacts
      CIRCLE_TEST_REPORTS: /tmp/test-results
      RAILS_TEST_SERVER_PORT: 8081
      TEST_DATABASE_URL: postgres://ubuntu:@127.0.0.1:5432/circle_test
      REDIS_URL: redis://localhost:6379
      RAISE_EXCEPTIONS: "true"
      # providing a fake DSN ensures sentry tests run with production parity
      SENTRY_DSN: stdout://12345:67890@sentry.localdomain/prefix/sentry/42
      RAILS_ENV: test
      RACK_ENV: test
      LOG_LEVEL: DEBUG
      DISABLE_SPRING: "true"
      STRIPE_ACCOUNT_ID: acct_15uapDIsgf92XbAO
      # used for private key extraction and usage in the jwt generator
      SF_JWT_PRIVATE_KEY_PATH: /home/circleci/project/private.key
      SF_QA_PACKAGING_EMAIL: mbianco+newstripeconnectorqa@stripe.com
      SF_USERNAME: <<parameters.account>>
      # SF_PASSWORD
      # SIGNALFX_TOKEN
    docker:
      # replace `:.*` with `@sha256:THE_SHA` to lock the build to a specific container SHA
      - image: cimg/ruby:2.7.6-browsers
      - image: cimg/postgres:13.5
        environment:
          POSTGRES_DB: circle_test
          POSTGRES_USER: ubuntu
          POSTGRES_PASSWORD: pg_password
      - image: cimg/redis:6.2

    steps:
      - browser-tools/install-chrome
      - browser-tools/install-chromedriver
      - checkout
      - sfdx/install: *sfdx_version
      - jq/install
      - ruby/install-deps:
          bundler-version: 2.3.9
      - run:
          command: mkdir -p $CIRCLE_ARTIFACTS $CIRCLE_TEST_REPORTS

      - run:
          name: Setting up https proxy
          command: |
            printf '127.0.0.1 stripe-netsuite-test.dev' | sudo tee -a /etc/hosts

            # https://github.com/stripe/stripe-netsuite/issues/1736
            sudo npm install -g nassau-https-proxy@1.0.4
      - run:
          name: Running https proxy
          # wait for up to 30m to ensure NS communication doesn't timeout; backoffs and temporary slowdowns could cause intermittent failures
          command: sudo PROXY_TIMEOUT=1800 FORWARD_PORT=$RAILS_TEST_SERVER_PORT nassau-https-proxy
          background: true

      - run:
          name: Database Migration
          command: |
            bundle exec ruby db/migration.rb
            # TODO our current migration script is hacky and needs to be reworked to be a standard migration
            # bundle exec sequel -m migrations $TEST_DATABASE_URL

      - run:
          name: Setup Salesforce Access
          command: |
            # https://stackoverflow.com/questions/14970663/why-doesnt-bash-flag-e-exit-when-a-subshell-fails
            set -Eeuo pipefail

            ./sfdx/bin/extract-private-key

            # not required to get an access token, but useful for domain and instance ID extraction
            sfdx auth:jwt:grant --clientid $SF_CONSUMER_KEY --jwtkeyfile=$SF_JWT_PRIVATE_KEY_PATH --username="$SF_USERNAME"

            # for debugging purposes
            sfdx auth:list --json

            export SF_INSTANCE_DOMAIN=$(sfdx auth:list --json | jq '.result[] | select(.username=="'$SF_USERNAME'").instanceUrl' | perl -nle 'm/https:\/\/(.*)\.my.salesforce.com/; print $1')
            export SF_INSTANCE_ID=$(sfdx auth:list --json | jq '.result[] | select(.username=="'$SF_USERNAME'").orgId')

            # now, we need to swap our jwt token for a access token
            $(cd sfdx/bin/jwt-generator && npm install &>/dev/null)
            export SF_ACCESS_TOKEN=$(node sfdx/bin/jwt-generator/index.js)

            # persist environment vars to the next job run
            # this is a hack but the best option circleci provides
            echo "export SF_ACCESS_TOKEN=$SF_ACCESS_TOKEN" >> $BASH_ENV
            echo "export SF_INSTANCE_DOMAIN=$SF_INSTANCE_DOMAIN" >> $BASH_ENV
            echo "export SF_INSTANCE_ID=$SF_INSTANCE_ID" >> $BASH_ENV

      - run:
          name: "CPQ QA Package Deployment"
          command: |
            if [ "$CIRCLE_NODE_INDEX" != "0" ]; then
              echo "Not first build node, exiting"
              exit 0
            fi

            source ./sfdx/bin/run-tests-helpers
            cd sfdx

            authorizeSalesforceAccount "$SF_QA_PACKAGING_EMAIL"

            # make sure the same API version is used for local deployments, otherwise you'll run into weird errors
            # for some reason, the `sfdx config:set apiVersion=52.0` doesn't work and gets overwritten

            # the current code should *always* be able to be deployed against the packaging org, if it can't be, this should block the build
            deploySource "$SF_QA_PACKAGING_EMAIL"

      # https://jira.corp.stripe.com/browse/PLATINT-1499
      - run:
          name: "CPQ Package Version Check"
          command: |
            if [ "$CIRCLE_NODE_INDEX" != "0" ]; then
              echo "Not first node, exiting"
              exit 0
            fi

            SF_ACCOUNT_WITH_QA_PACKAGE_INSTALLED=mbianco+cpqpackage@stripe.com

            if [ "$SF_USERNAME" != "$SF_ACCOUNT_WITH_QA_PACKAGE_INSTALLED" ]; then
              echo "Not the packaged org, exiting"
              exit 0
            fi

            cd sfdx

            # SF_QA_PACKAGING_EMAIL is authorized in the previous step, otherwise we would need to do this here

            latest_package_version=$(sfdx force:package1:version:list --json -u $SF_QA_PACKAGING_EMAIL | jq -r '.result[-1].Version')
            installed_package_version=$(sfdx force:package:installed:list -u $SF_USERNAME --json | jq -r '.result[] | select(.SubscriberPackageName == "QaStripeConnect").SubscriberPackageVersionNumber')

            # the installed package version always has `.1` appended
            if [[ "$latest_package_version.1" != $installed_package_version ]]; then
              echo "Latest package version ($latest_package_version) is not installed ($installed_package_version)"

              latest_package_id=$(sfdx force:package1:version:list --json -u $SF_QA_PACKAGING_EMAIL | jq -r '.result[-1].MetadataPackageVersionId')
              echo "https://appiphony92-dev-ed.lightning.force.com/packaging/installPackage.apexp?p0=$latest_package_id"

              exit 1
            fi

            echo "Latest package is installed"

      # always run bundle-audit in case new security issues are found without a Gemfile change
      # https://github.com/stripe/stripe-netsuite/issues/1713
      - run:
          name: Gem Security Audit
          command: |
            if [ "$CIRCLE_NODE_INDEX" == "0" ]; then
              bundle exec bundle-audit update && bundle exec bundle-audit check
            fi

      - run:
          name: Code Security Audit
          command: |
            if [ "$CIRCLE_NODE_INDEX" == "0" ]; then
              bundle exec brakeman -z
            fi

      - run:
          when: always
          no_output_timeout: "20m"
          command: |
            echo "Instance Domain: $SF_INSTANCE_DOMAIN"
            echo "Instance Id: $SF_INSTANCE_ID"
            echo "Access Token: $SF_ACCESS_TOKEN"

            # https://discuss.circleci.com/t/test-timings-are-still-missing-with-2-0-and-workflows/21247/14
            # https://github.com/CircleCI-Public/circleci-cli/blob/master/cmd/tests.go#L54
            SPLIT_TEST_FILES=$(circleci tests glob "test/**/test*.rb" | circleci tests split --split-by=timings --timings-type=filename)
            echo $SPLIT_TEST_FILES
            bundle exec rails test --ci-dir $CIRCLE_TEST_REPORTS --profile $SPLIT_TEST_FILES

      - run:
          # DO NOT change the name of this task; email redirects to data-io-bots match against this name
          name: Nightly Test Environment Cleanup
          when: always
          command: |
            # more info on why `CIRCLE_USERNAME` is used: https://github.com/stripe/stripe-netsuite/pull/2455
            if [ -z "$CIRCLE_USERNAME" ] && [ "$CIRCLE_NODE_INDEX" == "0" ]; then
              echo "Cleaning Test Environment"
            fi

      - store_test_results:
          path: /tmp/test-results

      # one entry for each directory we want to store
      - store_artifacts:
          path: /tmp/artifacts
      - store_artifacts:
          path: /tmp/test-results

  # prevent more than a single build from running at one time
  # the implementation below is customized to remove additional unneeded parameters
  # https://jira.corp.stripe.com/browse/REPROD-1231
  # https://github.com/eddiewebb/circleci-queue/blob/9e7fc054183e0bcd891f9258d2661bd9223ffe06/src/commands/until_front_of_line.yml#L36
  block_workflow:
    docker:
      - image: cimg/base:stable
    resource_class: small
    parameters:
      time:
        type: string
        default: "10"
        description: "How long to wait before giving up."
      confidence:
        type: string
        default: "1"
        description: "Due to scarce API, we need to requery the recent jobs list to ensure we're not just in a pending state for previous jobs.  This number indicates the threhold for API returning no previous pending jobs. Default is a single confirmation."
    steps:
      - run:
          name: Queue Until Front of Line
          command: |
            load_variables(){
              # just confirm our required variables are present
              : ${CIRCLE_BUILD_NUM:?"Required Env Variable not found!"}
              : ${CIRCLE_PROJECT_USERNAME:?"Required Env Variable not found!"}
              : ${CIRCLE_PROJECT_REPONAME:?"Required Env Variable not found!"}
              : ${CIRCLE_REPOSITORY_URL:?"Required Env Variable not found!"}
              : ${CIRCLE_JOB:?"Required Env Variable not found!"}
              VCS_TYPE="github"
            }
            fetch_filtered_active_builds(){
              jobs_api_url_template="https://circleci.com/api/v1.1/project/${VCS_TYPE}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}?circle-token=${CIRCLECI_API_KEY}&filter=running"
              echo "Attempting to access CircleCI api. If the build process fails after this step, ensure your CIRCLECI_API_KEY is set."
              curl -f -s $jobs_api_url_template > /tmp/jobstatus.json
              echo "API access successful"
            }
            fetch_active_workflows(){
              cp /tmp/jobstatus.json /tmp/augmented_jobstatus.json
              for workflow in `jq -r ".[] | .workflows.workflow_id" /tmp/augmented_jobstatus.json | uniq`
              do
                echo "Checking time of workflow: ${workflow}"
                workflow_file=/tmp/workflow-${workflow}.json
                curl -f -s "https://circleci.com/api/v2/workflow/${workflow}?circle-token=${CIRCLECI_API_KEY}" > ${workflow_file}
                created_at=`jq -r '.created_at' ${workflow_file}`
                echo "Workflow was created at: ${created_at}"
                cat /tmp/augmented_jobstatus.json | jq --arg created_at "${created_at}" --arg workflow "${workflow}" '(.[] | select(.workflows.workflow_id == $workflow) | .workflows) |= . + {created_at:$created_at}' > /tmp/augmented_jobstatus-${workflow}.json
                #DEBUG echo "new augmented_jobstatus:"
                #DEBUG cat /tmp/augmented_jobstatus-${workflow}.json
                mv /tmp/augmented_jobstatus-${workflow}.json /tmp/augmented_jobstatus.json
              done
            }
            update_comparables(){
              fetch_filtered_active_builds
              fetch_active_workflows
              load_current_workflow_values

              echo "This job will block until no previous workflows have *any* jobs running."
              oldest_running_build_num=`jq 'sort_by(.workflows.created_at)| .[0].build_num' /tmp/augmented_jobstatus.json`
              oldest_commit_time=`jq 'sort_by(.workflows.created_at)| .[0].workflows.created_at' /tmp/augmented_jobstatus.json`

              echo "Oldest job: $oldest_running_build_num"
              if [ -z $oldest_commit_time ];then
                echo "API Call for existing jobs failed, failing this build.  Please check API token"
                echo "All running jobs:"
                cat /tmp/jobstatus.json || exit 0
                echo "All running jobs with created_at:"
                cat /tmp/augmented_jobstatus.json || exit 0
                echo "All worfklow details."
                cat /tmp/workflow-*.json
                exit 1
              fi
            }
            load_current_workflow_values(){
              my_commit_time=`jq '.[] | select( .build_num == '"${CIRCLE_BUILD_NUM}"').workflows.created_at' /tmp/augmented_jobstatus.json`
            }
            cancel_current_build(){
              echo "Cancelleing build ${CIRCLE_BUILD_NUM}"
              cancel_api_url_template="https://circleci.com/api/v1.1/project/${VCS_TYPE}/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/${CIRCLE_BUILD_NUM}/cancel?circle-token=${CIRCLECI_API_KEY}"
              curl -s -X POST $cancel_api_url_template > /dev/null
            }
            #
            # We can skip a few use cases without calling API
            #
            if [ ! -z "$CIRCLE_PR_REPONAME" ]; then
              echo "Queueing on forks is not supported. Skipping queue..."
              # It's important that we not fail here because it could cause issues on the main repo's branch
              exit 0
            fi

            #
            # Set values that wont change while we wait
            #
            load_variables
            max_time=<<parameters.time>>
            echo "This build will block until all previous builds complete."
            echo "Max Queue Time: ${max_time} minutes."
            wait_time=0
            loop_time=11
            max_time_seconds=$((max_time * 60))
            #
            # Queue Loop
            #
            confidence=0
            while true; do
              update_comparables
              echo "This Workflow Timestamp: $my_commit_time"
              echo "Oldest Workflow Timestamp: $oldest_commit_time"
              if [[ "$oldest_commit_time" > "$my_commit_time" ]] || [[ "$oldest_commit_time" = "$my_commit_time" ]] ; then
                # API returns Y-M-D HH:MM (with 24 hour clock) so alphabetical string compare is accurate to timestamp compare as well
                # recent-jobs API does not include pending, so it is possible we queried in between a workfow transition, and we;re NOT really front of line.
                if [ $confidence -lt <<parameters.confidence>> ];then
                  # To grow confidence, we check again with a delay.
                  confidence=$((confidence+1))
                  echo "API shows no previous jobs/workflows, but it is possible a previous workflow has pending jobs not yet visible in API."
                  echo "Rerunning check ${confidence}/<<parameters.confidence>>"
                else
                  echo "Front of the line, WooHoo!, Build continuing"
                  break
                fi
              else
                echo "This build (${CIRCLE_BUILD_NUM}) is queued, waiting for build number (${oldest_running_build_num}) to complete."
                echo "Total Queue time: ${wait_time} seconds."
              fi
              if [ $wait_time -ge $max_time_seconds ]; then
                echo "Max wait time exceeded, cancelling build."
                cancel_current_build
                sleep 10 # wait for API to cancel this job, rather than showing as failure
                exit 1 # but just in case, fail job
              fi
              sleep $loop_time
              wait_time=$(( loop_time + wait_time ))
            done
